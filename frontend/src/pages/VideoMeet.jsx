import React, { useEffect, useRef, useState } from "react";
import Box from '@mui/material/Box';
import TextField from '@mui/material/TextField';
import Stack from '@mui/material/Stack';
import Button from '@mui/material/Button';
import io from 'socket.io-client'


const server_url = "http://localhost:8000";
let connections = {};
const peerConfigConnections={
    "iceServers":[
        {"urls":"stun:stun.l.google.com:19302"}
    ]
}

export default function VideoMeet(){
    let socketRef = useRef();
    let socketIdRef = useRef();
    let localVideoRef = useRef();
    const videoRef = useRef([])

    let [videoAvailable,setVideoAvailable] = useState(true);
    let [audioAvailable,setAudioAvailable] = useState(true);
    
    let [video,setVideo] = useState(false);
    let [audio,setAudio] = useState(false);
    
    let [screen,setScreen] = useState();
    let [showModal,setModel] = useState(true);
    let [ screenAvailable,setScreenAvailable] = useState();
    
    let [messages,setMessages] = useState([]);
    let [message,setMessage] = useState("");
    let [newMessages,setNewMessages] = useState(3);
    
    let [ askForUsername,setAskForUsername] = useState(true);
    let[username,setUsername] = useState("");
  
    let [ videos,setVideos] = useState([]);

    let gotMessageFromServer =(fromId,message)=>{
        let signal = JSON.parse(message);
        if(fromId!==socketIdRef.current){
            if(signal.sdp){
                connections[fromId].setRemoteDescription(new RTCSessionDescription(signal.sdp))
                .then(()=>{
                    if(signal.sdp.type === 'offer'){
                        connections[fromId].createAnswer()
                        .then((description)=>{
                           connections[fromId].setLocalDescription(description).then(()=>{
                            socketIdRef.current.emit("signal",fromId,JSON.stringify({"sdp":connections[fromId].localDescription}))
                           }).catch(e=>console.log(e));
                        }).catch(e=>console.log(e));
                    }
                }).catch(e=>console.log(e));
            }


            if(signal.ice){
                connections[fromId].addIceCandidates(new RTCIceCandidate(signal.ice)).catch(e=>console.log(e));
            }
        }
    }

    let addMessage =()=>{}

    let connectToSocketServer=()=>{
        console.log("This is worlking");
        socketRef.current = io.connect(server_url,{secure:false});
        socketRef.current.on('signal',gotMessageFromServer);

        socketRef.current.on('connect',()=>{

            socketRef.current.emit('join-call',window.location.href);
            socketIdRef.current = socketRef.current.id;
            
            socketRef.current.on("chat-message",addMessage);

            socketRef.current.on("user-left",(id)=>{
                setVideos((videos)=>videos.filter((video)=>video.scoketId!==id))
            })
            socketRef.current.on("user-joined",(id,clients)=>{
                clients.forEach((socketListId)=>{
                    connections[socketListId] = new RTCPeerConnection(peerConfigConnections);
                    connections[socketListId].onicecandidate =(event)=>{
                        if(event.candidate !==null){
                            socketRef.current.emit("signal",socketListId,JSON.stringify({'ice':event.candidate}))
                        }
                    }
                    connections[socketListId].onaddstream = (event)=>{
                        let videoExists = videoRef.current.find(video=>video.socketId === socketListId);
                        if(videoExists){
                            setVideo(videos=>{
                                const updatedVideos = video.map(video=>
                                    video.socketId == socketListId ? {...video,stream:event.stream}:video
                                );
                                videoRef.current = updatedVideos;
                                return updatedVideos;
                            })
                        }else{
                            let newVideo = {
                                socketId:socketListId,
                                stream:event.stream,
                                autoPlay:true,
                                playsinline:true
                            }
                            setVideos(videos=>{
                                const updatedVideos = [...videos,newVideo];
                                videoRef.current = updatedVideos;
                                return updatedVideos;
                            });
                        }
                    };
                    if(window.localStream !== undefined && window.localStream!==null){
                        connections[socketListId].addStream(window.localStream);
                    }else{
                       let blackSilence = (...args)=>new MediaStream(black(...args),silence());
                       window.localStream = blackSilence();
                       connections[socketIdRef].addStream(window.localStream);
                    }
                })
                if(id === socketIdRef.current){
                    for(let id2 in connections){
                        if(id2 === socketIdRef.current)continue;
                        try{
                            connections[id2].addStream(window.localStream)
                        }catch(e){

                        }
                        connections[id2].createOffer().then((description)=>{
                            connections[id2].setLocalDescription(description)
                            .then(()=>{
                                socketRef.current.emit("signal",id2,JSON.stringify({"sdp":connections[id2].localDescription}))
                            })
                            .catch(e=>console.log(e));
                        })
                    }
                }
            })
        })
    }

    const getPermissions =async ()=>{
        try{
            const videoPermission = await navigator.mediaDevices.getUserMedia({video:true});
            if(videoPermission){
                setVideoAvailable(true);
            }else {
                setVideoAvailable(false);
            }

            const audioPermission = await navigator.mediaDevices.getUserMedia({audio:true});
            if(audioPermission){
                setAudioAvailable(true);
            }else {
                setAudioAvailable(false);
            }

            if(navigator.mediaDevices.getDisplayMedia){
                setScreenAvailable(true);
            }else{
                setScreenAvailable(false);
            }

            if(videoAvailable || audioAvailable){
                const userMediaStream = await navigator.mediaDevices.getUserMedia({video:videoAvailable,audio:audioAvailable});
                if(userMediaStream){
                    window.localStream = userMediaStream;
                    if(localVideoRef.current){
                        localVideoRef.current.srcObject = userMediaStream;
                    }
                }
            }
        }catch(e){
            console.log(e);
        }

        

    }
    let getUserMediaSuccess = (stream)=>{
        try{

            window.localStream.getTracks().forEach(track=>track.stop())

        }catch(e){

        }
        window.localStream = stream;
        localVideoRef.current.srcObject = stream;

        for(let id in connections){
            if(id === socketIdRef.current) continue;
            connections[id].addStream(window.localStream)
            connections[id].createOffer().then((description)=>{
                connections[id].seetLocalDescription(description)
                .then(()=>{
                    socketIdRef.current.emit("signal",id,JSON.stringify({"sdp":connections[id].localDescription}))
                }).catch(e=>console.log(e)); 
            })
        }

        stream.getTracks().forEach(track=>track.onended =() =>{
            setVideo(false);
            setAudio(false);
            try{
                let track = localVideoRef.current.srcObject.getTracks()
                tracks.forEach(track=>track.stop())

            }catch(e){
                console.log(e);
            }

            //BlackSilenece
            let blackSilence = (...args)=>new MediaStream(black(...args),silence());
                       window.localStream = blackSilence();
                       localVideoRef.current.srcObject = window.localStream;

            for(let id in connections){
                connections[id].addStream(window.localStream)
                connections[id].setLocalDescriptipn(description)
                .then(()=>{
                    socketRef.current.emit("signal",id,JSON.stringify({"sdp":connections[id].localDescription}))
                    
                })
                .catch(e=>console.log(e));
            }
        })
    }

    let silence = ()=>{
        let ctx = new AudioContext();
        let oscillator = ctx.createOscillator();

        let dst = oscillator.connect(ctx.createMediaStreamDestination());

        oscillator.start();
        ctx.resume();
        return Object.assign(dst.stream.getAudioTracks()[0], {enabled:false})
    }


    let black = ({width=640,height = 480} = {})=>{
        let canvas = Object.assign(document.createElement("canvas"),{width,height});

        canvas.getContext('2d').fillRect(0,0,width,height);
        let stream = canvas.captureStream();
        return Object.assign(streamgetVideoTracks()[0],{enabled : false})
    }

    let getUserMedia=()=>{
        if((video && videoAvailable) ||(audio && audioAvailable)){
            navigator.mediaDevices.getUserMedia({video:video,audio:audio})
            .then(()=>{})
            .then((stream)=>{})
            .catch((e)=>{
                console.log(e);
            })
        }else{

            try{
                let tracks = localVideoRef.current.srcObject.getTracks();
                tracks.forEach(track=>track.stop())
            }catch(e){}
        }
    }

    useEffect(()=>{
        getPermissions();
    },[]);

    useEffect(()=>{
        if(video!==undefined && audio!=undefined){
            getUserMedia();
        }
    },[audio,video]);

    let getMedia = ()=>{
        setVideo(videoAvailable);
        setAudio(audioAvailable);
        connectToSocketServer();

    }


return(
  <>
  {askForUsername ?
   <> <h1>Enter into the lobby</h1>
    <TextField id="outlined-basic" label="username" value={username} onChange={e=>setUsername(e.target.value)} variant="outlined" />
    <Button variant="contained" onClick={connectToSocketServer}>connect</Button>

    <div>
        <video ref={localVideoRef} autoPlay muted></video>
    </div>
</> :
<>
<video ref = {localVideoRef} autoPlay muted></video>

{videos.map((video)=>{
    <div key={video.socketId}>
         
    </div>
})}
</>
}
   
    </>

)
}